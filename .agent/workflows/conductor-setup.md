---
description: 初始化專案並建立 Conductor 環境
---

## 1.0 系統指令
你是一個 AI 代理。你的主要功能是使用 Conductor 方法論設定並管理軟體專案。本文件是你的作業協定。請精確且依序遵守這些指示。不要進行假設。

**關鍵：** 你必須驗證每次工具呼叫的成功。如果任何工具呼叫失敗，你「必須」立即停止當前操作，向使用者宣佈失敗，並等待進一步指示。

---

## 1.1 開始「恢復 (RESUME)」檢查
**協定：在開始設定之前，使用狀態檔案確定專案狀態。**

1.  **讀取狀態檔案：** 檢查 `conductor/setup_state.json` 是否存在。
    - 如果不存在，這是新專案設定。直接前往步驟 1.2。
    - 如果存在，讀取其內容。

2.  **根據狀態恢復：**
    - 令 JSON 檔案中 `last_successful_step` 的值為 `STEP`。
    - 根據 `STEP` 的值，跳轉到下一個邏輯章節。
    - 如果 `STEP` 是 "2.1_product_guide"，宣佈 "正在恢復設定：產品指南 (`product.md`) 已完成。接下來，我們將建立產品準則。" 並轉到**區段 2.2 產生產品準則 (Product Guidelines)**。
    - 如果 `STEP` 是 "2.2_product_guidelines"，宣佈 "正在恢復設定：產品指南和產品準則已完成。接下來，我們將定義技術堆疊。" 並轉到**區段 2.3 產生技術棧 (Tech Stack)**。
    - 如果 `STEP` 是 "2.3_tech_stack"，宣佈 "正在恢復設定：產品指南、準則和技術堆疊已定義。接下來，我們將選擇程式碼風格指南。" 並**呼叫`/conductor-setup-track` workflow** 接續**區段 2.4 選擇指南 (Select Guides)**。
    - 如果 `STEP` 是 "2.4_code_styleguides"，宣佈 "正在恢復設定：所有指南和技術堆疊已配置。接下來，我們將定義專案工作流。" 並**呼叫`/conductor-setup-track` workflow** 接續**區段 2.5 選擇工作流程 (Select Workflow)**。
    - 如果 `STEP` 是 "2.5_workflow"，宣佈 "正在恢復設定：初始專案骨架已完成。接下來，我們將生成第一個 Track。" 並**呼叫`/conductor-setup-track` workflow** 接續。
    - 如果 `STEP` 是 "3.3_initial_track_generated"：
        - 宣佈："專案已完成初始化。你可以透過 `/conductor-new-track` 建立新 Track，或透過 `/conductor-implement` 開始實作現有 Track。"
        - 停止 `conductor-setup` 程序。
    - 如果 `STEP` 無法辨識，宣佈錯誤並停止。

---

## 1.2 預初始化概覽
1.  **提供高階概述：**
    -   向使用者展示初始化程序的以下概述：
        ```text
        歡迎使用 Conductor。我將引導你執行以下步驟來設定你的專案：
        1. **專案探索：** 分析目前目錄以確定這是新專案還是現有專案。
        2. **產品定義：** 協作定義產品的願景、設計準則和技術堆疊。
        3. **配置：** 選擇合適的程式碼風格指南並自定義你的開發工作流。
        4. **Track 生成：** 定義初始 Track 並自動生成詳細計畫以開始開發。
        
        讓我們開始吧！
        ```

---

## 2.0 階段 1：流暢的專案設定
**協定：遵循此序列與使用者進行引導式、互動式的設定。**

### 2.0 專案啟動
1.  **偵測專案成熟度：**
    -   **分類專案：** 根據以下指標決定專案是 "Brownfield" (現有) 還是 "Greenfield" (新)：
    -   **Brownfield (現有專案) 指標：**
        -   檢查是否存在版本控制目錄：`.git`、`.svn` 或 `.hg`。
        -   如果存在 `.git` 目錄，執行 `git status --porcelain`。如果輸出不為空，則分類為 "Brownfield" (髒倉庫)。
        -   檢查是否存在相依性清單：`package.json`、`pom.xml`、`requirements.txt`、`go.mod`。
        -   檢查是否存在包含程式碼檔案的原始碼目錄：`src/`、`app/`、`lib/`。
        -   如果滿足上述「任一」條件（版本控制目錄、髒 git 倉庫、相依性清單或原始碼目錄），則分類為 **Brownfield**。
    -   **Greenfield (新專案) 條件：**
        -   當且僅當「未發現任何」"Brownfield 指標"「且」目前目錄為空或僅包含通用文件（例如：單個 `README.md` 檔案）且不含功能性程式碼或相依性時，才分類為 **Greenfield**。
2.  **根據成熟度執行工作流：**
    -   **如果是 Brownfield：**
        -   宣佈偵測到現有專案。
        -   如果 `git status --porcelain` 命令（作為 Brownfield 指標的一環執行）顯示有未提交的變更，請告知使用者："警告：你的 Git 倉庫中有未提交的變更。請在繼續之前提交或暫存你的變更，因為 Conductor 將會進行修改。"
        -   **開始 Brownfield 專案初始化協議：**
            -   **1.0 分析前確認：**
                1.  **告知使用者：** 說明偵測到 brownfield（現有）專案。
                2.  **請求權限：** 請求執行唯讀掃描以分析專案的權限，並使用以下結構提供選項：
                    ```text
                    A) 是 
                    B) 否 
                    請回覆 A 或 B。
                    ```
                3.  **處理拒絕：** 如果權限被拒絕，停止程序並等待進一步的使用者指示。
                4.  **確認：** 獲得確認後，進入下一步。

            -   **2.0 程式碼分析：**
                1.  **宣佈行動：** 告知使用者你現在將執行程式碼分析。
                2.  **優先分析 README：** 如果 `README.md` 檔案存在，請先從它開始分析。
                3.  **全面掃描：** 將分析擴展到其他相關檔案，以瞭解專案的用途、技術和慣例。

            -   **2.1 檔案大小與相關性分類：**
                1.  **尊重忽略檔案：** 在掃描任何檔案之前，你「必須」檢查是否存在 `.geminiignore` 和 `.gitignore` 檔案。如果兩者之一或兩者皆存在，你「必須」使用其組合模式從分析中排除檔案和目錄。若有衝突，`.geminiignore` 中的模式應優先於 `.gitignore`。這是避免掃描像 `node_modules` 這種佔用大量 Token 且不相關檔案的主要機制。
                2.  **高效列出相關檔案：** 為了列出待分析檔案，你「必須」使用尊重忽略檔案的命令。例如，你可以使用 `git ls-files --exclude-standard -co | xargs -n 1 dirname | sort -u`，這會列出所有相關目錄（由 Git 追蹤加上其他非忽略檔案），而不會列出每一個檔案。如果未使用 Git，你必須建構一個 `find` 命令來讀取忽略檔案並修剪對應的路徑。
                3.  **回退至手動忽略：** 「僅當」`.geminiignore` 和 `.gitignore` 皆不存在時，你才應回退至手動忽略常見目錄。範例命令：`ls -lR -I 'node_modules' -I '.m2' -I 'build' -I 'dist' -I 'bin' -I 'target' -I '.git' -I '.idea' -I '.vscode'`。
                4.  **優先處理關鍵檔案：** 從篩選後的檔案清單中，優先分析高價值且體積小的檔案，例如 `package.json`、`pom.xml`、`requirements.txt`、`go.mod` 以及其他配置或清單檔案。
                5.  **處理大型檔案：** 對於篩選清單中任何單個超過 1MB 的檔案，「不要」讀取整個檔案。相反地，僅讀取前 20 行和後 20 行（使用 `head` 和 `tail`）來推斷其用途。

            -   **2.2 擷取與推斷專案上下文：**
                1.  **嚴格的檔案存取：** 「不要」要求提供更多檔案。你的分析應「僅基於」提供的檔案片段和目錄結構。
                2.  **擷取技術堆疊：** 分析提供的清單檔案內容以識別：
                    -   程式語言
                    -   框架（前端和後端）
                    -   資料庫驅動程式
                3.  **推斷架構：** 使用檔案樹骨架（頂層 2 層）來推斷架構類型（例如：Monorepo、微服務、MVC）。
                4.  **推斷專案目標：** 嚴格基於提供的 `README.md` 標題或 `package.json` 描述，用一句話總結專案目標。
        -   **完成 brownfield 初始化協議後，進入 2.1 節中的「生成產品指南」。**
    -   **如果是 Greenfield：**
        -   宣佈將初始化一個新專案。
        -   進入此檔案的下一步。

3.  **初始化 Git 倉庫 (針對 Greenfield)：**
    -   如果 `.git` 目錄不存在，執行 `git init` 並向使用者報告已初始化一個新的 Git 倉庫。

4.  **詢問專案目標 (針對 Greenfield)：**
    -   **向使用者提出以下問題，並在獲得回覆後才進入下一步：** 「你想要建立什麼？」
    -   **關鍵：在使用者提供回覆之前，你「必須不得」執行任何工具呼叫。**
    -   **收到使用者回覆後：**
        -   執行 `mkdir -p conductor`。
        -   **初始化狀態檔案：** 在建立 `conductor` 目錄後，你「必須」立即建立 `conductor/setup_state.json`，其確切內容如下：
            `{"last_successful_step": ""}`
        -   將使用者的回覆寫入 `conductor/product.md` 的 `# Initial Concept` 標題下。

5.  **繼續：** 立即進入下一個區段。

### 2.1 生成產品指南 (互動式)
1.  **介紹區段：** 宣佈你現在將協助使用者建立 `product.md`。
2.  **按順序提問：** 一次提出一個問題。在提出下一個問題之前，等待並處理使用者的回應。繼續此互動程序，直到收集到足夠資訊。
        -   **限制：** 詢問次數上限為 5 個問題。
        -   **建議：** 對於每個問題，根據常見模式或你已擁有的上下文，生成 3 個高品質的建議答案。
        -   **範例主題：** 目標使用者、目標、功能等。
        *   **一般準則：**
            *   1. **分類問題類型：** 在構思任何問題之前，你必須先將其目的分類為「累加式 (Additive)」或「排除式選擇 (Exclusive Choice)」。
                *   使用**累加式**進行腦力激盪和定義範圍（例如：使用者、目標、功能、專案準則）。這些問題允許複選。
                *   使用**排除式選擇**進行基礎、單一的決定（例如：選擇主要的技術、特定的工作流規則）。這些問題僅需要單選。

            *   2. **構思問題：** 根據分類，你必須遵守以下規則：
                *   **如果是累加式：** 構思一個鼓勵多點思考的開放式問題。然後，你必須展示選項清單，並在問題後直接加上確切的片語「(可複選)」。
                *   **如果是排除式選擇：** 構思一個引導使用者做出單一、清晰決定的直接問題。你「不得」加上「(可複選)」。

            *   3. **互動流程：**
                    *   **關鍵：** 你必須按順序（一個接一個）提問。不要在一次對話中提出多個問題。等待使用者對每個問題的回應。
                *   每個多選題的最後兩個選項「必須」是「自行輸入答案」和「自動生成並審閱 product.md」。
                *   在繼續之前，透過總結來確認你的理解。
            - **格式：** 你「必須」將這些選項展示為垂直列表，每個選項佔一行。
            - **結構：** 
                ```text
                A) [選項 A]
                B) [選項 B]
                C) [選項 C]
                D) [自行輸入答案]
                E) [自動生成並審閱 product.md]
                ```
    -   **針對現有專案 (BROWNFIELD)：** 根據程式碼分析提出具備專案上下文感知的問題。
    -   **自動生成邏輯：** 如果使用者選擇選項 E，立即停止此區段的提問。運用你的最佳判斷，根據先前的回答和專案上下文推斷剩餘細節，生成完整的 `product.md` 內容，寫入檔案並進入下一個區段。
3.  **草擬文件：** 對話完成（或選擇選項 E）後，生成 `product.md` 的內容。如果選擇了選項 E，請根據先前的回答和專案上下文運用最佳判斷推斷剩餘細節。鼓勵你詳細說明收集到的細節，以建立一份全面的文件。
    -   **關鍵：** 生成內容的事實來源「僅為使用者選取的答案」。你「必須」完全忽略你提出的問題以及你展示但未選取的 `A/B/C` 選項。
    -   **行動：** 採用使用者選定的答案，並將其綜合成文件中的規範章節。鼓勵你擴展使用者的選擇以創造全面且精緻的產出。在最終檔案中「不要」包含對話選項 (A, B, C, D, E)。
4.  **使用者確認循環：** 向使用者展示草擬的內容以供審閱，並開始確認循環。
    ```text
    我已經草擬了產品指南。請審閱以下內容：
    
    > ```markdown
    > [此處為草擬的 product.md 內容]
    > ```

    接下來你想做什麼？
    A) **核准：** 文件正確無誤，我們可以繼續。
    B) **建議修改：** 告訴我需要修改什麼。
    請回覆 A 或 B。
    ```
    - **循環：** 根據使用者的回覆，套用變更並重新展示文件，或在核准時中斷循環。
5.  **寫入檔案：** 核准後，將生成的內容附加到現有的 `conductor/product.md` 檔案中，保留 `# Initial Concept` 區段。
6.  **提交狀態：** 成功建立檔案後，你「必須」立即將確切內容寫入 `conductor/setup_state.json`：
    `{"last_successful_step": "2.1_product_guide"}`
7.  **繼續：** 寫入狀態檔案後，立即進入下一個區段。

### 2.2 生成產品準則 (互動式)
1.  **介紹區段：** 宣佈你現在將協助使用者建立 `product-guidelines.md`。
2.  **按順序提問：** 一次提出一個問題。在提出下一個問題之前，等待並處理使用者的回應。繼續此互動程序，直到收集到足夠資訊。
    -   **限制：** 詢問次數上限為 5 個問題。
    -   **建議：** 對於每個問題，根據常見模式或你已擁有的上下文，生成 3 個高品質的建議答案。為每個答案提供簡短的理由，並標註你強力推薦的一個。
    -   **範例主題：** 文風、品牌訊息、視覺識別等。
    *   **一般準則：**
        *   1. **分類問題類型：** 在構思任何問題之前，你必須先將其目的分類為「累加式 (Additive)」或「排除式選擇 (Exclusive Choice)」。
            *   使用**累加式**進行腦力激盪和定義範圍（例如：使用者、目標、功能、專案準則）。這些問題允許複選。
            *   使用**排除式選擇**進行基礎、單一的決定（例如：選擇主要的技術、特定的工作流規則）。這些問題僅需要單選。

        *   2. **構思問題：** 根據分類，你必須遵守以下規則：
            *   **建議：** 展示選項時，應為每個選項提供簡短理由並標註你強力推薦的一個。
            *   **如果是累加式：** 構思一個鼓勵多點思考的開放式問題。然後，你必須展示選項清單，並在問題後直接加上確切的片語「(可複選)」。
            *   **如果是排除式選擇：** 構思一個引導使用者做出單一、清晰決定的直接問題。你「不得」加上「(可複選)」。

        *   3. **互動流程：**
                *   **關鍵：** 你必須按順序（一個接一個）提問。不要在一次對話中提出多個問題。等待使用者對每個問題的回應。
            *   每個多選題的最後兩個選項「必須」是「自行輸入答案」和「自動生成並審閱 product-guidelines.md」。
            *   在繼續之前，透過總結來確認你的理解。
        - **格式：** 你「必須」將這些選項展示為垂直列表，每個選項佔一行。
        - **結構：**
            ```text
            A) [選項 A]
            B) [選項 B]
            C) [選項 C]
            D) [自行輸入答案]
            E) [自動生成並審閱 product-guidelines.md]
            ```
    -   **自動生成邏輯：** 如果使用者選擇選項 E，立即停止此區段的提問，並進入下一步草擬文件。
3.  **草擬文件：** 對話完成（或選擇選項 E）後，生成 `product-guidelines.md` 的內容。如果選擇了選項 E，請根據先前的回答和專案上下文運用最佳判斷推斷剩餘細節。鼓勵你詳細說明收集到的細節，以建立一份全面的文件。
    -  **關鍵：** 生成內容的事實來源「僅為使用者選取的答案」。你「必須」完全忽略你提出的問題以及你展示但未選取的 `A/B/C` 選項。
    -  **行動：** 採用使用者選定的答案，並將其綜合成文件中的規範章節。鼓勵你擴展使用者的選擇以創造全面且精緻的產出。在最終檔案中「不要」包含對話選項 (A, B, C, D, E)。
4.  **使用者確認循環：** 向使用者展示草擬的內容以供審閱，並開始確認循環。
    ```text
    我已經草擬了產品準則。請審閱以下內容：

    > ```markdown
    > [此處為草擬的 product-guidelines.md 內容]
    > ```

    接下來你想做什麼？
    A) **核准：** 文件正確無誤，我們可以繼續。
    B) **建議修改：** 告訴我需要修改什麼。

    請回覆 A 或 B。
    ```
    - **循環：** 根據使用者的回覆，套用變更並重新展示文件，或在核准時中斷循環。
5.  **寫入檔案：** 核准後，將生成的內容寫入 `conductor/product-guidelines.md` 檔案中。
6.  **提交狀態：** 成功建立檔案後，你「必須」立即將確切內容寫入 `conductor/setup_state.json`：
    `{"last_successful_step": "2.2_product_guidelines"}`
7.  **繼續：** 寫入狀態檔案後，立即進入下一個區段。

### 2.3 生成技術堆疊 (互動式)
1.  **介紹區段：** 宣佈你接下來將協助定義技術堆疊。
2.  **按順序提問：** 一次提出一個問題。在提出下一個問題之前，等待並處理使用者的回應。繼續此互動程序，直到收集到足夠資訊。
    -   **限制：** 詢問次數上限為 5 個問題。
    -   **建議：** 對於每個問題，根據常見模式或你已擁有的上下文，生成 3 個高品質的建議答案。
    -   **範例主題：** 程式語言、框架、資料庫等。
    *   **一般準則：**
        *   1. **分類問題類型：** 在構思任何問題之前，你必須先將其目的分類為「累加式 (Additive)」或「排除式選擇 (Exclusive Choice)」。
            *   使用**累加式**進行腦力激盪和定義範圍（例如：使用者、目標、功能、專案準則）。這些問題允許複選執行。
            *   使用**排除式選擇**進行基礎、單一的決定（例如：選擇主要的技術、特定的工作流規則）。這些問題僅需要單選。

        *   2. **構思問題：** 根據分類，你必須遵守以下規則：
            *   **建議：** 展示選項時，應為每個選項提供簡短理由並標註你強力推薦的一個。
            *   **如果是累加式：** 構思一個鼓勵多點思考的開放式問題。然後，你必須展示選項清單，並在問題後直接加上確切的片語「(可複選)」。
            *   **如果是排除式選擇：** 構思一個引導使用者做出單一、清晰決定的直接問題。你「不得」加上「(可複選)」。

        *   3. **互動流程：**
                *   **關鍵：** 你必須按順序（一個接一個）提問。不要在一次對話中提出多個問題。等待使用者對每個問題的回應。
            *   每個多選題的最後兩個選項「必須」是「自行輸入答案」和「自動生成並審閱 tech-stack.md」。
            *   在繼續之前，透過總結來確認你的理解。
        - **格式：** 你「必須」將這些選項展示為垂直列表，每個選項佔一行。
        - **結構：**
            ```text
            A) [選項 A]
            B) [選項 B]
            C) [選項 C]
            D) [自行輸入答案]
            E) [自動生成並審閱 tech-stack.md]
            ```
    -   **針對現有專案 (BROWNFIELD)：**
            -   **關鍵警告：** 你的目標是記錄專案「現有」的技術堆疊，而不是提議變更。
            -   **陳述推斷的堆疊：** 根據程式碼分析，你「必須」陳述你所推斷的技術堆疊。不要提供任何其他選項。
            -   **要求確認：** 陳述偵測到的堆疊後，你「必須」詢問使用者簡單的確認以繼續，選項如：
                ```text
                A) 是，這正確無誤。
                B) 否，我需要提供正確的技術堆疊。
                ```
            -   **處理異議：** 如果使用者對建議有異議，請瞭解其輸入並允許他們在最後手段下，手動提供正確的技術堆疊。
    -   **自動生成邏輯：** 如果使用者選擇選項 E，立即停止此區段的提問。運用你的最佳判斷，根據先前的回答和專案上下文推斷剩餘細節，生成完整的 `tech-stack.md` 內容，寫入檔案並進入下一個區段。
3.  **草擬文件：** 對話完成（或選擇選項 E）後，生成 `tech-stack.md` 的內容。如果選擇了選項 E，請根據先前的回答和專案上下文運用最佳判斷推斷剩餘細節。鼓勵你詳細說明收集到的細節，以建立一份全面的文件。
    -   **關鍵：** 生成內容的事實來源「僅為使用者選取的答案」。你「必須」完全忽略你提出的問題以及你展示但未選取的 `A/B/C` 選項。
    -   **行動：** 採用使用者選定的答案，並將其綜合成文件中的規範章節。鼓勵你擴展使用者的選擇以創造全面且精緻的產出。在最終檔案中「不要」包含對話選項 (A, B, C, D, E)。
4.  **使用者確認循環：** 向使用者展示草擬的內容以供審閱，並開始確認循環。
    ```text
    我已經草擬了技術堆疊文件。請審閱以下內容：
    
    > ```markdown
    > [此處為草擬的 tech-stack.md 內容]
    > ```
    
    接下來你想做什麼？
    
    A) **核准：** 文件正確無誤，我們可以繼續。
    B) **建議修改：** 告訴我需要修改什麼。
    
    請回覆 A 或 B。
    ```
    - **循環：** 根據使用者的回覆，套用變更並重新展示文件，或在核准時中斷循環。
6.  **寫入檔案：** 核准後，將生成的內容寫入 `conductor/tech-stack.md` 檔案中。
7.  **提交狀態：** 成功建立檔案後，你「必須」立即將確切內容寫入 `conductor/setup_state.json`：
    `{"last_successful_step": "2.3_tech_stack"}`
8.  **繼續：** 呼叫`/conductor-setup-track` workflow 接續。